# 小贺八股

## 三、cpp基础

### 1.cpp的四种智能指针

1. uniqu_ptr用delete删除了拷贝构造函数和赋值运算符函数

2. sharedptr内部是两个指针，分别指向数据和管理块，所以sp的大小是常规指针的两倍

3. 共有操作：get、reset、swap、*、-》、bool

4. 使用move可以转移up到另一个up或sp，原来的up变为空指针，不再拥有内存控制权

5. up不需要维护计数，性能更高

6. weakptr是一种弱引用，指向sp管理的对象，不影响对象的生命周期，不改变sp的引用计数，无论是否有wp，只要sp的引用为零，则对象直接销毁

7. wp需要调用lock函数转换为sp来解引用对象，lock返回的是sp对象，若不存在，则返回空的sp

8. wp的expired（）可以判断是否被释放

9. wp的使用场景：实现缓存、避免循环引用、实现单例模式

10. 为什么makeshared更安全，因为makeshared是一个函数模板，他分配一次内存并初始化对象返回sp。而sp（new T）则要分配两次，一次是分配t的内存，一次是分配管理块的内存。

11. 避免用同一个raw pointer初始化多个shared-ptr，会导致生成两个独立的控制块，即两个控制块的引用计数是不会相互影响的，两个都是1。且在析构的时候，会释放两次同一块内存。

### 2.Cpp中的内存分配

1. 栈、堆、全局/静态存储区、常量存储区、代码区

### 3.指针参数传递和引用传递

1. 内存空间的开辟，指针传参是值传参

2. 对局部变量的操作

3. 编译角度的差异

### 3.const和static

#### 1.static控制存储方式和可见性

1. 局部变量：

2. 全局变量

3. 函数

4. 类

5. 类成员/类函数声明

6. （静态非常量数据成员，只能在类外定义和初始化，类内仅仅是声明，不需要在编译时确定值，运行时可以被修改，因此可在任意位置初始化和赋值。静态常量则是必须在类外定义的同时初始化，而且只能初始化一次，若定义为constexpr则可以在类中直接进行初始化，此时必须是一个常量表达式）

#### 2.const

1. 基本数据类型

2. 指针变量和引用变量

3. 函数中

4. 类中

5. 类对象

6. 成员函数

## 四、类和数据抽象

### 1.什么是类的继承

1. 类与类之间的关系：包含，使用，继承

2. 继承的相关概念

3. 继承的特点

4. 访问控制、兼容性原则

### 2.什么是组合

### 3.构造函数和析构函数可否抛出异常

### 4.类如何实现只能静态分配和只能动态分配

### 5.何时需要初始化列表，过程是什么

1. 当初始化一个引用成员变量

2. 初始化一个const成员变量

3. 调用基类构造函数，而该构造函数有一组参数

4. 调用一个成员类的构造函数，该类有一组参数

5. 编译器会意义操作初始化列表，列表中的顺序由类中的成员声明顺序决定。

## 五、STL容器和算法

### 1.STL介绍：

1. **容器**是一种用于存放数据的类模板

2. **算法**是一种方法模板

3. **迭代器**是重载了指针相关操作的类模板，每个STL容器都有自己的迭代器

4. **仿函数**是重载了operator()的类或类模板

5. **配接器**用来修饰容器或者仿函数或迭代器接口

6. **配置器**负责空间管理与配置，是一个实现了动态空间配置、空间管理、空间释放的类模板。

7. **SGI的双层配置器**，第一级使用malloc和free分配和回收，第二级根据大小，查询链表

8. **vector**自动扩容，连续线性空间，三个迭代器，拷贝扩容引起迭代器失效；**list**双向链表，一个指针，动态对每个元素分配和释放空间，迭代器不失效；**deque**双向开口的连续线性空间。不同vector，没有容量这一概念，以动态的分段连续空间组合而成。

## 七、cpp11新特性

### 1.空指针nullptr

nullptr是为了替代NULL而出现的。使用null会导致重载特性的混乱；nullptr的类型为nullptr_t，可以隐式转换为任何类型或成员指针。

### 2.lambda表达式

1. 是一种`语法糖`；`lambda`返回的是函数对象（重载了调用运算符的类对象，即**函数对象**或者**仿函数**）。

2. 方括号开始，圆括号指定参数，->指定返回值类型，花括号写函数体结束：`auto f = [](int a)->int{return; a};`

3. []的功能：**闭包**。

4. 原理：定义一个lambda表达式后，lambda会生成一个重载了()的匿名类，称之为**闭包类型（closure type）**。运行时，lambda会返回一个匿名的闭包实例（注意，是实例，即闭包类型这一类的实例化对象），且是一个右值。

5. 闭包的强大之处正在与可以通过传值或引用的方式**捕捉**其封装作用域内（lambada所处的作用域，即与lambda在一个代码块内的变量）的变量。捕获方式：值，引用，默认全部参数，当前对象的值和引用

6. **重要的应用**：将其应用于函数的参数，可以实现回调函数。（vector的count_if）

### 3.右值引用

完美转发，移动语义，万能引用，模板参数推导，引用折叠

### 4.泛化的常量表达式

1. 用变量指定数组长度不可行，必须用const，但是cpp中的constexpr告诉编译器这是一个编译期常量，甚至可以将一个函数声明为编译器常量表达式

### 5.初始化列表

只是进行了语法增强（即以前也有初始化列表），即可以使用initializer_list接受变长度对象初始化列表，但是列表仍然是静态构造的。

### 6.统一的初始化语法

{}花括号

### 7.类型推导

`auto`和`decltype`两种。

auto属于静态的类型推导，即当我们知道类型是没有问题的但类型名太长不想写的时候用。CPP仍然是强类型的静态语言，仍然会进行静态类型检查。  

decltype用于获取一个表达式的类型，而不求值。左值则返回T&，将亡值返回T&&，纯右值返回T

## 14、STL迭代器源码与trait编程技法

### 14.2迭代器设计模式：

在设计模式中，对迭代器的描述如下：迭代器是一种能够顺序访问容器中每个元素的方法，该方法不能暴露内部表达方式。

OOP：方法和成员变量在一个类中实现。动态多态，运行时使用虚函数表确认数据类型，需要在运行时去检索虚函数表，效率相对较低

**GP（泛型编程）**:多种数据类型在同一种算法或结构上都可以操作；静态多态，编译期确定具体数据类型，执行效率高，编译器负担大

STL采用的是GP而不是OOP，迭代器也是一种模板，通过迭代器，容器和算法可以有机的绑定在一起。无需针对不同算法来设计迭代器。

### 14.3智能指针

迭代器其实也是一种智能指针，能进行解引用和->操作。

不同容器的细节不同，因此不同容器的迭代器耶不同。

原生指针也是一种迭代器

### 14.4template参数推导

## 15、STL序列式容器

`array(build in)`, `vector(heap, priority_queue)`,`list`,`slist`,`deque(stack queue)`

所有容器的源码都包含三个部分：**迭代器**、**构造函数**、**属性获取**

### 15.3Vector

主要有三个迭代器

属性：end begin front back size max_size capacity empty

pop和Push：push_back会检查是否有备用空间，并调整finish。若不够，会分配原来的两倍空间，并拷贝过去。pop_back会放弃尾端元素，将finish往前移动

erase：清除指定位置元素，或清除一个范围内的所有元素，将后面所有元素往前移动，开销大，不适合频繁操作

insert：三种情况

由一块连续的内存空间存储，可以想数组一样操作，动态扩容，随机访问方便，支持下标和at访问，由于顺序存储，插入和删除复杂度是On，只能在末端push和pop。扩容需要整体进行分配和拷贝以及原空间的释放。

### 15.4List

双向链表

每每插入或删除就删除或配置一个元素，对空间运用有绝对的精准，一点也不浪费，对于任何位置插入和删除，list永远是常数空间。

list源码分了两个部分，一个部分是list结构，另一部分是list节点结构；可以理解为，将指针变量和数据变量分开，原因是迭代器遍历是不需要数据成员的，只需要指针。

迭代器重载了++和--，指向next和prev

list的迭代器不是普通指针

> 是一种双向循环链表
> 
> 不适用连续内存动态操作
> 
> 在内部方便进行插入删除
> 
> 可以在两端进行push和pop
> 
> 相比于vector占用内存多
> 
> 不支持随机访问

### 15.5deque



# 零零碎碎的八股

## 1.Allocator

Allocator（概念）是对访问、寻址、分配、释放、构造和析构策略的封装。是一个满足特定要求的类。标准库中需要分配释放存储空间的容器都需要一个Allocator，除了std::array。

## 2.内存池

## 3.线程池

## 4.如何理解cpp是强类型语言

C++（通常简写为cpp）被认为是一种强类型语言，这主要体现在它对于数据类型的严格要求和管理方式上。强类型语言与弱类型语言的主要区别在于它们如何对待变量类型、类型转换以及类型检查。以下是理解C++作为强类型语言的几个方面：

1. **静态类型检查**：  
   C++是一种静态类型语言，这意味着在编译时，编译器会检查程序中所有变量的类型，确保它们的使用符合类型规则。如果尝试将一个类型的值赋给另一个不兼容类型的变量，或者调用一个类型不兼容的参数给函数，编译器将报错。这种静态类型检查有助于提前发现和纠正错误，避免在运行时出现意外情况。

2. **明确的类型定义**：  
   在C++中，每个变量都必须显式地声明其类型。这种明确的类型定义使得代码更加清晰，易于理解和维护。同时，它也有助于编译器进行更有效的优化。

3. **类型转换的显式性**：  
   在C++中，当需要将一个类型的值转换为另一个类型时，通常需要显式地进行类型转换（如使用`static_cast`、`dynamic_cast`、`reinterpret_cast`或`const_cast`）。这种显式性减少了因隐式类型转换而导致的错误，提高了代码的安全性和可读性。

4. **类型安全**：  
   由于C++对类型进行了严格的管理和检查，因此它被认为是一种类型安全的语言。类型安全意味着在编译时能够捕获许多类型相关的错误，从而减少运行时错误和内存损坏的风险。

5. **泛型编程和模板**：  
   C++支持泛型编程和模板，这使得程序员可以编写与类型无关的代码。虽然这看起来像是弱化了类型的要求，但实际上，模板和泛型编程是在编译时根据具体类型生成类型安全的代码。这种技术不仅提高了代码的复用性，还保持了C++作为强类型语言的特性。

> 综上所述，C++作为强类型语言，通过静态类型检查、明确的类型定义、类型转换的显式性、类型安全以及泛型编程和模板等特性，确保了代码的高质量和可靠性。这些特性使得C++成为开发高性能、高可靠性软件系统的理想选择。

## 5.cpp的右值、纯右值和将亡值

1. 最初可以根据能否取地址来区分是左值还是右值

2. **表达式**：定义：由运算符(operator)和运算对象(operand)①构成的计算式（类似于数学上的算术表达式）；举例：字面值(literal)和变量(variable)是最简单的表达式，函数的返回值也被认为是表达式。

3. 表达式是可求值的，求值得到的结果有两个属性，类型和值类别。在c++11以后，表达式按值类别分，必然属于以下三者之一：左值(left value,lvalue)，将亡值(expiring value,xvalue)，纯右值(pure rvalue,pralue)。其中，左值和将亡值合称泛左值(generalized lvalue,glvalue)，纯右值和将亡值合称右值(right value,rvalue)。

> 实际上无论左值还是右值，都没有很精确的定义，其只是表征了表达式的属性，区别主要体现在使用上

4. **左值**：能用`&`取地址的表达式时左值；**纯右值**：本身就是字面值；求职结果相当于字面值或是一个不具名的临时对象。（*p是左值，因为(*p)返回的是p指向的实体，是可以取地址的，而&a是右值）**将亡值**：返回右值引用的函数的调用表达式、转换为右值引用的转换函数表达式。（将亡值是随着右值引用而引入的）可以理解为，**即将用于移动语义初始化或赋值的右值称之为将亡值。**

5. 在cpp中使用左值去初始化对象或为对象赋值时，会调用拷贝构造函数或赋值构造函数。而使用一个右值来初始化或赋值时，会调用移动构造函数或移动赋值运算符来移动资源，从而避免拷贝，提高效率

## 6.Placement new

## 7.CPP如何实现多态

## 8.嵌套类别定义

typedef

## 9.std::bind

## 10.restrict关键字

## 11.cpp中函数返回局部对象的时候，其返回值是左值还是右值

在C++中，当函数返回局部对象时，其返回值通常被视为一个右值（rvalue）。这是因为局部对象在函数返回后其生命周期即将结束，它们不再是任何可访问的左值表达式的结果。然而，这个规则在C++11及以后的版本中因为移动语义（move semantics）和右值引用（rvalue references）的引入而变得更加复杂和有趣。

### C++11及以后

在C++中，当函数返回局部对象时，其返回值通常被视为一个右值（rvalue）。这是因为局部对象在函数返回后其生命周期即将结束，它们不再是任何可访问的左值表达式的结果。然而，这个规则在C++11及以后的版本中因为移动语义（move semantics）和右值引用（rvalue references）的引入而变得更加复杂和有趣。

在C++11及以后的版本中，当函数返回一个局部对象时，编译器会尝试使用移动语义来优化这个过程。如果函数的返回类型有适当的移动构造函数或移动赋值操作符，则编译器可以“移动”局部对象的资源（如动态分配的内存、文件句柄等）到返回的对象中，而不是进行复制。这样做通常更高效，因为它可以避免不必要的资源分配和释放。

尽管如此，从技术上讲，这个局部对象的引用仍然是一个右值。但通过使用右值引用来表示这些“可以被移动”的表达式，我们可以实现高效的资源转移。

> 当C++函数返回局部对象时，其返回值是一个右值。但在C++11及以后，由于移动语义和右值引用的引入，编译器可以优化这个过程，通过移动局部对象的资源到返回的对象中，而不是进行复制，从而提高效率。

## 12.右值引用、万能引用、完美转发、模板参数推导


