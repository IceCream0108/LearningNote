# 一、深入浅出go语言

## 第四章、复杂数据类型

### 4.3、map

1. 声明，使用var

2. make创建

3. 遍历，顺序是随机的

4. 元素的查找，由于直接索引map['key']，若不存在则返回对应值类型的零值，因此会有歧义，即返回的零值不知道是由于不存在键值对还是存在但是键值对的值为零值的歧义。因此采用value，exist：=map[key]的方式消除了查找的歧义。

5. 删除：delete（map，key）

6. **存储结构解析**：hamp结构；bmap数据结构

### 4.4、channel

许多观点认为channel是消息队列或维为了线程同步而创建的数据结构。

1. 创建，需要make关键字，并指定存储的数据类型，第二个参数表明缓冲区大小，若不指定，则代表无缓冲区。
   
   ```go
   msgChannel := make(chan int, 100)
   ```
   
   channel读写数据的特点决定了缓冲区的意义。channel可以看作一个消息通道，通道的主要作用就是保证数据通过，因此，除了向其中写入数据外，还需要从其中读取数据。在没有缓冲区的情况下，当读操作就绪时才能写入数据。这如同一个没有仓库的货站，必须有等待接收货物的车辆，送货车辆才能顺畅送货；否则，送货车辆只能停在货站等待。而缓冲区就如同货站的仓库，即使没有接收车辆，送货车辆也可以向货站送货，因为可以临时将货物放入仓库中。

2. 读写，都使用左箭头<-，channel的位置决定是读操作还是写操作。对空chan读和对满chan写都会阻塞。输出的数据可以直接到打印台如`fmt.Println(<-msgChannel)`。

3. 实现原理
   
   1. channel的数据结构，hchan，包括元素数量，缓冲区大小，缓冲区指针（指向循环队列），元素大小，关闭状态，元素数据类型，已被读取的数据位置，当前已经写入的数据位置，等待写入和等待读取的阻塞协程队列。
   
   2. 写入的过程
   
   3. 读取的过程

4. 与消息队列的对比：消息队列可以回溯，但channel消费后就被移除（覆盖么？）；消息队列中能被多个消费者消费，channel中则不行；channel是进程级缓存，只能用于协程通信，而消息队列可以用于进程间；重点不一样。。。。

### 4.5、自定义结构体

1. 自定义数据类型

## 第六章、函数

### 6.1函数在go中的地位

1. 函数和方法的区别：方法的接收者；

### 6.2、函数的定义

1. 函数参数：值类型和指针类型

2. 返回值：位于声明的最后，且可以有多个返回值（两种返回方式，一种是在函数体内显示声明，显示return返回，第二种是在函数声明处显式声明，在函数体内赋值，并隐式return）。多返回值的原理可以理解为底层编译时将返回值视作变量，并直接进行操作。

### 6.3、模块和包

1. 使用go mod init name创建模块。模块下会有一个mod文件，该文件是整个模块共用的配置文件，其作用是管理整个模块的外部依赖包。

2. 本地包管理：跨包代码引用，文件夹路径与包名称并无硬性关系。

3. 模块名和文件夹名称的关系：.go文件内声明的包名称才是引入时用的，引入时并不看文件夹名称，保持一致是一个好习惯。

4. 当两个文件中定义的包名相同，可以定义包的别名`别名 “addres to package”。·`

5. go中的常量初始化、变量初始化、名为init的函数会被隐式的自动执行，而main是程序的入口。

6. 对外部依赖越少的，执行优先级越高，先加载被依赖的包，因为常量肯定不依赖于变量，所以常量优先于变量，init会在常量和变量之后执行。main最后执行。

7. 匿名包实现函数导入：因为若不显示使用引入的包，则会报错。所以为了解决这种，代码内不需显式调用，但是需要该包的init函数在后台运行是，就使用_作为匿名包调用，此时不显示调用包内代码，调用了初始化函数，但不会报错

### 6.4、将函数当作变量使用

1. 将函数赋值给变量：即函数可以像普通数值一样赋给变量，**暂存函数**成为可能，函数的声明被抽象为数据类型层面

2. 可以通过变量调用函数，`Function_Variable_Name()`

3. 应用场景：使用map可以将字符串与函数做映射

### 6.6、匿名函数和闭包

1. 为什么需要匿名函数：当函数只在特定位置调用而不需要复用，就可以定义匿名函数（与cpp中的lambda当作回调函数有什么关系？）

2. 匿名函数定义：`func() {Function Body}`。可以当作函数参数传入声明同样签名函数变量为参数的函数。

3. 当函数之间进行调用时，往往会被处理为多个栈帧的创建和释放，但go语言在编译匿名函数时会采用内联编译，即将调用与被调用编译在一起，平铺式的复制到调用处（类似于cpp的内联函数？），实际执行时会减小栈帧，对性能有一定提升

#### 6.6.2、闭包

```go
func getAnonymousFunc() func(){
    i:=0
    f:=func(){
    //局部变量自增
    i++
    //打印局部变量
    fmt.Println(i)
    }
    return f
}
```

1. 改代码定义了一个函数即getAnonymousFunc（闭包函数），该函数用于生成一个函数对象，可以从返回值func()看出。

2. 该闭包函数定义了一个局部变量i，且i定义与匿名函数之外

3. 匿名函数修改了i的值，一般说来，当外部的闭包函数执行结束，内部的局部变量会被释放，也就是i会被销毁，但是连着两次调用闭包函数，**i不仅存在，还进行了递增**，这是为什么呢？因为局部变量会随着所处函数栈帧的销毁而销毁。

4. **闭包的意义**：该闭包函数中的局部变量i会被分配在**堆空间**，即使外部闭包函数执行完毕，对应的栈内存销毁，i也不会销毁，且由于匿名函数一直保持对i的引用，变量i也不会被GC回收。无论是从getAnonymousFunc()的定义形式，还是其最终内存分配策略，或者代码的执行效果，都可以看出，getAnonymousFunc()生成的匿名函数就像一个封闭的、独立的小王国，具有一直驻留在内存的“环境变量”（我们姑且将闭包看作一个独立的运行环境），同时具有自己的执行逻辑。如同“闭包”这个字眼所表达的那样。

### 6.7函数的强制类型转换

6.7.1从数据类型的定义到函数类型的定义：在不考虑具体实现的情况下，函数要素可以抽象为**参数+返回值的组合**，这种定义不涉及具体的实现，就如同uint8和uint32不考虑具体数值，只限定数据长度一样

6.7.2从数据类型的强制转换到函数类型的强制转换：同数值的强制类型转换，不对变量进行类型声明，由编译器进行类型推导，赋值阶段会出现隐式的类型强制转换

6.7.3函数类型强制转换的意义：在go中**数据类型可以作为参数、返回值、函数的接收者（receiver，从而为数据类型绑定方法）等，这意味着，我们不仅可以像传递普通变量一样传递函数对象，还可以为函数绑定方法，而绑定后的方法可以被函数对象调用，相当于凭空为函数扩展了功能，如以下代码所示。**。通过强制转化，可以让多个与F1结构相同的函数拥有F1所绑定的方法，即此时F1成为了提供公共能力的载体。

6.7.4利用强制转换为函数绑定方法：即创建一个与多个待绑定函数【Target_Functions】类型相同的函数类型Inter_Funcion，为该类型绑定一个test函数，此时将每一个Target_Functions都强制转换为Inter_Function，此时每个新对象都拥有了test方法。

### 6.8、闭包的使用

传统的理解是：封装了变量和函数的独立环境

1. 闭包无法修改包外部的变量。当将闭包外的变量以函数传参的方式传值给闭包函数，函数会复制该变量的值，并在该包中修改，但是这个修改是不会影响到外部的原变量的。即闭包里面的函数，只能修改闭包里面的变量。

2. 可以以参数的形式传参给闭包函数，此时闭包函数内的函数的操作就可以影响到外部的变量。

## 第八章、GO的面向对象

> 重点：
> 
> 面向对象的本质
> 
> go实现封装
> 
> go实现继承
> 
> go实现多态
> 
> go中的面向接口编程

### 8.1、面向对象编程的本质

1. 构建和设计项目时，首先考虑的是行动的主体--对象，抽象出对象，并为对象赋予相关的行为和字段，整个项目的运转通过对象之间的交互来实现，就像人类社会的分工一样

2. 三大特性：封装、继承、多态

### 8.2、Go实现封装

> 封装是将属于某个对象的字段和行为抽象出来，形成一个有机体，在易于维护和契合事物特质的同时，可以用访问权限机制保证安全

1. 使用结构体对字段和方法进行封装，结构体中本身可以包含字段，使用大小写实现访问权限控制。将某个函数的**接收者**指定为结构体，可以实现为结构体绑定方法。

2. 为值类型绑定方法：将方法绑定到值类型上，则在方法内修改接收者的字段也不会影响原变量。`func (worker Worker) do(){Function Body}`

3. 为指针类型绑定方法：更常用，可以修改原变量的字段，`func (worker *Worker) do(){Function Body}`

### 8.3、Go语言实现继承

在面向对象的编程中，继承的原意是代码复用，尽量避免重复。但是Go中并无继承机制，只能实现类似继承

1. 利用组合集成其他对象的能力：当有结构体Human和Student时，若想要学生拥有Human的方法，则在Student结构体中声明一个Human字段即可，则此时Student实例就拥有了Human的方法，这种方式称为**组合**，即在一个结构体中声明另一个结构体类型的字段
   
   ```go
   type Human struct{
       name string
   }
   func (human *Human) speak(){fmt.Pringln("my name is ", human.name}
   
   type Student struct{
       human Human
   }
   h := Human{name : "Mike"}
   student := Student{human:h}
   student.human.speak()
   ```

2. 字段匿名化实现继承：
   Go允许字段的匿名化，因此省略student中的字段名称后，效果如下。则创建student时也可以省略字段名
   
   ```go
   type Human struct{
       name string
   }
   func (human *Human) speak(){fmt.Pringln("my name is ", human.name}
   
   type Student struct{
        Human
   }
   h := Human{name : "Mike"}
   student := Student{h,} //省略字段名称human直接赋予Human结构体填充字段，因为类型匹配，所以合理
   student.speak()
   ```
   
   省略字段名后，利用Student创建实例时，会按字段顺序进行匹配，将h赋值给第一个字段Human；匿名化使得函数调用变味了student.speak()。本质上还是student调用匿名Human类字段的方法，形式上实现了继承。此时若使用`fmt.Pringln("%v", student)`能看到`{Human:{name:Mike}}`,即匿名字段的实际名称为类型名字即Human。

3. 匿名字段的支持：**匿名字段如何注入结构体呢**？即：对没有名称的字段，为实例填充字段时会按顺序匹配来进行填充，类型不匹配则会报错

4. 多继承：同样，赋予同一个结构体多个结构体的匿名字段，则该结构体可以直接通过匿名调用的方式调用字段结构体的方法，实现类似多继承（但是填充的时候，要依次为子字段创建实例，有点麻烦，是否可以用：=来进行实时创建）

### 8.4、Go语言实现多态

> 在面向对象的编程中，多态有两种，类的多态和方法的多态。
> 
> 类的多态通过继承实现，在Go中目前无法实现，因为继承是伪继承，后续通过接口实现
> 
> 方法的多态是指在父类和子类中定义了某个方法，方法签名完全相同，使用时会根据对象的类型去定位实际执行的函数

1. 利用方法重写无法实现方法多态：利用组合，重写方法并不会调用重写的函数，仍然调用原先的函数。原因是go中的继承本质是组合，而非真正的继承，无法在父类对象（子类对象的成员字段）中调用子类对象的函数，因为父类对象中没有指向子类对象的指针

2. 正确的多态：将子类实例作为参数传入父类方法，根据不同类的子类实例，调用不同的方法，但是由于go中不存在继承关系，因此也就不能找到一个类来涵盖多种子类，仍然无法实现多态。因此要用面向接口的编程

### 8.5、面向接口编程

> 面向接口编程是指声明或定义对象时，将对象的类型定义为接口类型，而不使用具体类别，因为一个接口可以代表/涵盖多种具体类型。如此一来，当对象类型发生变更时，只要新类型实现了该接口，那么只需修改对象的赋值操作，后续代码操作均无需修改。这种编码方式，解耦了对象的赋值和操作两部分。

1. Go语言中的接口：也是使用type关键字，可以理解为接口也是自定义类型，其中声明了若干方法但却不实现，方法的具体实现交给类来实现。接口类型的变量可以引用任何实现了这些方法的对象，Go语言中的接口类型是一个动态类型，他们可以引用任何类型的变量，即可以保存任何实现了该方法的值的引用。一个重要优点就是他解耦了对象的赋值和操作两个部分。由于接口是定义了对象的行为而不是具体实现，因此需要增添功能时，或支持新的类型时，只需定义新的接口或实现已有的接口，而不需要修改现有的代码，使得设计更加可扩展和模块化。

2. 当结构体或数据类型实现了某个接口A的全部方法，那么就可以称该结构体和类型实现了A接口。如果某个接口中没有任何方法的声明，则为空接口，所有类型均可被视为空接口，也是Go语言中定义的特殊接口`type any = interface{}`。即any指任意数据类型

3. 接口的实现：若函数签名相同，并实现了函数，则称之为实现了接口。若将拟实现多态的输入函数参数声明为相应的接口类型IF，在函数中调用接口的函数，而有A,B,C三类结构体实现了接口IF，则此时可以将A,B,C三类实例传入同一个函数，并在函数体中调用接口对象的函数，则可以根据不同的实例调用不同的A,B,C的方法，实现了根据传入参数的类型调用不同的函数，实现了多态。

4. 接口实现多态：即，接口是作为接受不同类型对象的载体，且由于接口只声明方法而不实现方法，即该载体可以接受实现了函数签名相同的不同结构体，但各个结构体的具体实现又不同，从而实现多态。

5. 接口的典型应用：**1）接口嵌套**，或接口组合， 以此实现接口复用<span style = "back-ground: yellow;"><font color = 'red'>（没看懂例子，多看几遍）</font></span>；2）伪继承和接口实现：go中的继承都是伪继承，即通过组合实现。即A实现了接口I，B中组合了结构体A，则B也视作实现了接口I。即接口与实现类的关联，可以视作是松散的契约关系，只要类在形式上拥有某接口的**所有方法**，即视作该类实现了该接口。

## 第九章、并发

> 重要内容：线程概念、三种线程模型、协程的工作原理、Go中的协程同步、利用channel实现协程同步、让出时间片、Go语言中的单例。

### 9.1、线程的概念

1. 分为用户线程和内核线程。在用户态，每个线程可以理解为是一块内存地址，包含了线程执行所需的信息，如程序计数器、局部变量表、方法栈等，这块内存完全由线程私有，即不能访问其他线程的内存，也不能被访问；同时还有共享内存，即涉及线程安全问题；而有些操作必须在内核态执行，因此打通用户态和内核态的通道也是必备的。

2. 多线程并发，即单个时间点只有一个线程在工作，但是宏观上看起来就像是多个线程一起同时执行一样，即并发，逻辑流上的重合。但是线程切换是有成本的，即cpu上下文切换，常见场景如：时间片轮转、主动让出、线程阻塞、被打断、硬件中断等。

### 9.2、线程模型

1. 基于用户线程和内核线程的关系，提出了三种模型M:1、1:1、M:N三种。（用户：内核）

2. 三种线程在线程切换和线程的生命周期两个方面各有优劣。

### 9.3、协程的工作原理

1. 协程是M:N模型的一种体现

2. 使用go指令即可启动一个协程，go会创建一个新的子协程来执行go中对应的后续指令，且为了让子协程获得执行机会，需要调用sleep让主协程休眠，否则主协程退出会导致子协程来不及运行结束。

3. 可以使用go加匿名函数来执行不需要复用的多条指令（若需要复用则直接封装成函数）

4. GPM模型：1）G：是goroutine的缩写，go关键字启动的协程会被封装为一个对象，作为具体操作指令的载体；2）P：是processor的缩写，代表协程处理器。Go中的多个协程会分配给一个内核线程，但是一个G不会直接与内核线程关联，而是进入一个由P维护的队列，并为了尽力避免内核线程的切换而进行调度，调度算法由go自身通过P实现；3）M：是machine的缩写，代表一个内核线程，是指令的实际执行者，**一个M和一个P绑定在一起**，M负责从P维护的G队列上依次获得G对象进行处理。

5. 调度策略：1）G中遇到了I/O阻塞时；2）P中的G全部执行完毕；3）全局队列；4）：自旋。即协程的调度是在编程语言层面实现的，而不是完全交给CPU进行处理。

6. M:N调度复杂，风险高，部分场景用另外两种效果更好。M:N适用于大量的协程/线程并发（往往是异步任务），但是启动多少内核线程也是一个问题，通过GOMAXPROCS控制GPM中的P数量，默认情况下P的数量与cpu核心数相同，可以通过runtime.GOMAXPROCS()或者环境变量来设置。

### 9.4、Go中的协程同步

1. Mutex：sys.Mutex{}，Lock()和defer Unlock()

2. RWMutex，是为了增加读数据并发量，同时保持共享数据稳定状态而提出的，读锁为共享锁，写锁为独占锁。共享锁是对于同一个信号量，可以被多个协程多次加锁，而独占锁则要求信号量对象没有被其他对象所锁定，无论是读锁还是写锁。`lock  := sync.RWMutex  lock.RLock() lock.RUnlock lock.Lock() lock.Unlock()`。读锁和写锁只是对传统的延续，而不是真的要读或者写才行。

3. WaitGroup：通过设置计数器数值来让主协程阻塞，通过add来添加计数器数值，协程中的done函数可以让计数器减一，在计数器归零前主协程都阻塞在wait()函数处。







# 二、C++服务器开发精髓

## 三、多线程编程与资源同步

### 3.1、线程的基本概念及常见问题

> 进程本身什么也不做，只提供上下文环境容器，实际是线程执行，即一个进程至少有一个线程，该线程为主线程

1. 主线程退出，支线程：windows中，主线程推出会导致整个进程直接结束。linux中则工作线程不会退出，此时会变成**僵尸进程**，使用ps-ef查看，有defunc字段的即僵尸进程

2. 某个线程崩溃，会导致进程退出么：一般来说，每个线程都是独立执行的单位，都有自己的上下文堆栈，一个线程崩溃不会对其他线程造成影响。但是在通常情况下，一个线程崩溃也会导致整个进程退出。例如在Linux操作系统中可能会产生一个Segment Fault错误，这个错误会产生一个信号，操作系统对这个信号的默认处理就是结束进程，这样整个进程都被销毁，在这个进程中存在的其他线程自然也就不存在了。

### 3.2、线程的基本操作

1. 线程创建：pthread_create，线程函数的签名必须使用规定格式，即对参数个数、类型、返回个数都有要求

2. cpp11的std::thread类：可以将任意函数当作线程函数。保证该线程类对象在线程函数期间是有效的，否则会崩溃。因此有detach函数，可以将线程对象与线程函数脱离关系，即使对象被销毁，线程函数也可以继续运行（原理是啥？）

3. 获取线程ID：linux有三种方法：使用pthread_create时，传入的第一个参数就可以取到线程ID；pthread_t pthread_self(void)；通过系统调用syscall；第一种和第二种结果一样，都是pthread_t类型，输出一块内存空间地址，即tid指向线程对象的空间结构，由于不同的进程可能有同样的地址的内存块，因此一二种方法的输出可能是一样的，第三种是系统范围内全局唯一的，也就是LWP的ID，即轻量级进程（是linux实现的线程，可以多了解一下）。

4. cpp11获取线程ID：可以使用`std::this_thread.get_id()`，其返回值是一个`std::thread::id`的包装类型，不可以强制转换为整型，因此一般直接用cout输出，或转换为ostringstream对象，在转换为字符串，再把字符串转换为整形。

5. 等待线程结束：linux：pthread_join用于等待线程结束退出并接受他的返回值，被称为汇接（join）。在等待期间会挂起当前线程，不会消耗cpu时间片，知道等待的线程退出，该线程才会被唤醒接着执行；cpp11：统一了linux和windows，使用std::thread.join()来等待，然而使用该方法必须保证，该线程处于运行状态，即cpp11中称之为可汇接的（joinable）,若目标线程已退出，则会崩溃，因此也用joinable方法来判断是否可以join（那要是判断是否可以join的时候突然退出咋办）

### 3.3、惯用法：将c++类对象实例指针作为线程函数的参数

1. 使用C++面向对象的方式对线程函数进行封装，若不用11的线程类，则函数只能是静态方法。若用11的线程类对象，则可以直接用实例函数当作线程函数，但必须显示的传递类对象实例指针，即this指针作为构造函数给线程类。

2. 如果不使用C++11的语法，那么线程函数只能使用类的静态方法，且函数签名必须符合线程函数的签名要求。如果是类的静态方法，就无法访问类的实例方法了。为了解决这个问题，我们在实际开发中往往会在创建线程时将当前对象的地址（this指针）传递给线程函数，然后在线程函数中将该指针转换为原来的类实例，再通过这个实例就可以访问类的所有方法了。

3. **使用时，thread接受一个可调用对象作为参数，可以是函数指针，lambda表达式，函数对象或是bind的返回值等，若是类成员函数则需要&取实例函数指针，而普通函数的名字就是指针，即地址，类成员函数还需传入this指针。**

### 3.4、整型变量的原子操作

1. 线程同步技术指的是，多个线程同时操作某个资源，我们需要采取一些措施保护资源，预防引起冲突，如死锁或得到一些意料之外的结果。

2. 为什么给整型变量赋值不是原子操作：赋值，自增和自减操作，从汇编角度来看一般是三条指令，将一个变量的值赋给另一个变量，也是多个指令，非原子操作。

3. cpp11 对整型变量原子操作的支持：atomic模板类，linux的g++编译器遵循了11的规范，即atomic的拷贝构造函数使用delete删除，无法进行拷贝：即不能使用`std::atomic<int> value = 99;`只能使用`std::atomic<int> value; value = 99;`

4. 常见重载的操作：=，store，load，exchange。。。。。。

### 3.5、Linux线程同步对象



## 四、网络编程重难点解析

### 4.1、应该熟练掌握的socket函数

socket bind listen connect accept send recv select gethostbyname close shutdown setsockopt getsockopt

### 4.5select函数的用法和原理



## 七、单个服务的基本结构

### 4.2、TCP通信的基本流程

服务器：调用socket创建socket，利用bind绑定到ip+端口，调用listen监听，当有客户端来连接，调用accept，产生一个新的用于通信的socket，根据新的客户端使用send和recv进行通信，结束后，调用close关闭监听socket

客户端：调用socket创建socket，调用connect尝试连接，连接成功后调用recv或send，结束后调用close关闭socket

### 7.1、网络通信组件的效率问题

流行的框架如libevent、libuv、boost asio等。网络通信框架是由这些基础的socket API构成的。

### 7.4、Reactor模式

主流通信库如libevent、java的netty以及python的twisted等，都使用Reactor模式。是一种事件处理设计模式，在I/O请求到达后，服务器处理程序使用I/O复用技术同步的将这些请求派发给相关的请求处理程序。

1. 表面上很简单，但是其思想不简单，解决了计算机中存在的一个普遍问题，请求太多，资源太少，即一个对外服务的程序，其接受的各种输入输出非常多，但是服务程序处理能力有限。即通常情况下，请求之和一般远远大于处理程序的数量，即高并发。

2. 模块：资源请求事件、多路复用器与事件分发器、事件处理器。

### 7.5、one thread on loop思想
