# 一、深入浅出go语言

## 第四章、复杂数据类型

### 4.3、map

1. 声明，使用var

2. make创建

3. 遍历，顺序是随机的

4. 元素的查找，由于直接索引map['key']，若不存在则返回对应值类型的零值，因此会有歧义，即返回的零值不知道是由于不存在键值对还是存在但是键值对的值为零值的歧义。因此采用value，exist：=map[key]的方式消除了查找的歧义。

5. 删除：delete（map，key）

6. **存储结构解析**：hamp结构；bmap数据结构

### 4.4、channel

许多观点认为channel是消息队列或维为了线程同步而创建的数据结构。

1. 创建，需要make关键字，并指定存储的数据类型，第二个参数表明缓冲区大小，若不指定，则代表无缓冲区。
   
   ```go
   msgChannel := make(chan int, 100)
   ```
   
   channel读写数据的特点决定了缓冲区的意义。channel可以看作一个消息通道，通道的主要作用就是保证数据通过，因此，除了向其中写入数据外，还需要从其中读取数据。在没有缓冲区的情况下，当读操作就绪时才能写入数据。这如同一个没有仓库的货站，必须有等待接收货物的车辆，送货车辆才能顺畅送货；否则，送货车辆只能停在货站等待。而缓冲区就如同货站的仓库，即使没有接收车辆，送货车辆也可以向货站送货，因为可以临时将货物放入仓库中。

2. 读写，都使用左箭头<-，channel的位置决定是读操作还是写操作。对空chan读和对满chan写都会阻塞。输出的数据可以直接到打印台如`fmt.Println(<-msgChannel)`。

3. 实现原理
   
   1. channel的数据结构，hchan，包括元素数量，缓冲区大小，缓冲区指针（指向循环队列），元素大小，关闭状态，元素数据类型，已被读取的数据位置，当前已经写入的数据位置，等待写入和等待读取的阻塞协程队列。
   
   2. 写入的过程
   
   3. 读取的过程

4. 与消息队列的对比：消息队列可以回溯，但channel消费后就被移除（覆盖么？）；消息队列中能被多个消费者消费，channel中则不行；channel是进程级缓存，只能用于协程通信，而消息队列可以用于进程间；重点不一样。。。。

### 4.5、自定义结构体

1. 自定义数据类型

## 第六章、函数

### 6.1函数在go中的地位

1. 函数和方法的区别：方法的接收者；

### 6.2、函数的定义

1. 函数参数：值类型和指针类型

2. 返回值：位于声明的最后，且可以有多个返回值（两种返回方式，一种是在函数体内显示声明，显示return返回，第二种是在函数声明处显式声明，在函数体内赋值，并隐式return）。多返回值的原理可以理解为底层编译时将返回值视作变量，并直接进行操作。

### 6.3、模块和包

1. 使用go mod init name创建模块。模块下会有一个mod文件，该文件是整个模块共用的配置文件，其作用是管理整个模块的外部依赖包。

2. 本地包管理：跨包代码引用，文件夹路径与包名称并无硬性关系。

3. 模块名和文件夹名称的关系：.go文件内声明的包名称才是引入时用的，引入时并不看文件夹名称，保持一致是一个好习惯。

4. 当两个文件中定义的包名相同，可以定义包的别名`别名 “addres to package”。·`

5. go中的常量初始化、变量初始化、名为init的函数会被隐式的自动执行，而main是程序的入口。

6. 对外部依赖越少的，执行优先级越高，先加载被依赖的包，因为常量肯定不依赖于变量，所以常量优先于变量，init会在常量和变量之后执行。main最后执行。

7. 匿名包实现函数导入：因为若不显示使用引入的包，则会报错。所以为了解决这种，代码内不需显式调用，但是需要该包的init函数在后台运行是，就使用_作为匿名包调用，此时不显示调用包内代码，调用了初始化函数，但不会报错
