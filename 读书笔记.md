# 一、深入浅出go语言

## 第四章、复杂数据类型

### 4.3、map

1. 声明，使用var

2. make创建

3. 遍历，顺序是随机的

4. 元素的查找，由于直接索引map['key']，若不存在则返回对应值类型的零值，因此会有歧义，即返回的零值不知道是由于不存在键值对还是存在但是键值对的值为零值的歧义。因此采用value，exist：=map[key]的方式消除了查找的歧义。

5. 删除：delete（map，key）

6. **存储结构解析**：hamp结构；bmap数据结构

### 4.4、channel

许多观点认为channel是消息队列或维为了线程同步而创建的数据结构。

1. 创建，需要make关键字，并指定存储的数据类型，第二个参数表明缓冲区大小，若不指定，则代表无缓冲区。
   
   ```go
   msgChannel := make(chan int, 100)
   ```
   
   channel读写数据的特点决定了缓冲区的意义。channel可以看作一个消息通道，通道的主要作用就是保证数据通过，因此，除了向其中写入数据外，还需要从其中读取数据。在没有缓冲区的情况下，当读操作就绪时才能写入数据。这如同一个没有仓库的货站，必须有等待接收货物的车辆，送货车辆才能顺畅送货；否则，送货车辆只能停在货站等待。而缓冲区就如同货站的仓库，即使没有接收车辆，送货车辆也可以向货站送货，因为可以临时将货物放入仓库中。

2. 读写，都使用左箭头<-，channel的位置决定是读操作还是写操作。对空chan读和对满chan写都会阻塞。输出的数据可以直接到打印台如`fmt.Println(<-msgChannel)`。

3. 实现原理
   
   1. channel的数据结构，hchan，包括元素数量，缓冲区大小，缓冲区指针（指向循环队列），元素大小，关闭状态，元素数据类型，已被读取的数据位置，当前已经写入的数据位置，等待写入和等待读取的阻塞协程队列。
   
   2. 写入的过程
   
   3. 读取的过程

4. 与消息队列的对比：消息队列可以回溯，但channel消费后就被移除（覆盖么？）；消息队列中能被多个消费者消费，channel中则不行；channel是进程级缓存，只能用于协程通信，而消息队列可以用于进程间；重点不一样。。。。

### 4.5、自定义结构体

1. 自定义数据类型

## 第六章、函数

### 6.1函数在go中的地位

1. 函数和方法的区别：方法的接收者；

### 6.2、函数的定义

1. 函数参数：值类型和指针类型

2. 返回值：位于声明的最后，且可以有多个返回值（两种返回方式，一种是在函数体内显示声明，显示return返回，第二种是在函数声明处显式声明，在函数体内赋值，并隐式return）。多返回值的原理可以理解为底层编译时将返回值视作变量，并直接进行操作。

### 6.3、模块和包

1. 使用go mod init name创建模块。模块下会有一个mod文件，该文件是整个模块共用的配置文件，其作用是管理整个模块的外部依赖包。

2. 本地包管理：跨包代码引用，文件夹路径与包名称并无硬性关系。

3. 模块名和文件夹名称的关系：.go文件内声明的包名称才是引入时用的，引入时并不看文件夹名称，保持一致是一个好习惯。

4. 当两个文件中定义的包名相同，可以定义包的别名`别名 “addres to package”。·`

5. go中的常量初始化、变量初始化、名为init的函数会被隐式的自动执行，而main是程序的入口。

6. 对外部依赖越少的，执行优先级越高，先加载被依赖的包，因为常量肯定不依赖于变量，所以常量优先于变量，init会在常量和变量之后执行。main最后执行。

7. 匿名包实现函数导入：因为若不显示使用引入的包，则会报错。所以为了解决这种，代码内不需显式调用，但是需要该包的init函数在后台运行是，就使用_作为匿名包调用，此时不显示调用包内代码，调用了初始化函数，但不会报错

### 6.4、将函数当作变量使用

1. 将函数赋值给变量：即函数可以像普通数值一样赋给变量，**暂存函数**成为可能，函数的声明被抽象为数据类型层面

2. 可以通过变量调用函数，`Function_Variable_Name()`

3. 应用场景：使用map可以将字符串与函数做映射

### 6.6、匿名函数和闭包

1. 为什么需要匿名函数：当函数只在特定位置调用而不需要复用，就可以定义匿名函数（与cpp中的lambda当作回调函数有什么关系？）

2. 匿名函数定义：`func() {Function Body}`。可以当作函数参数传入声明同样签名函数变量为参数的函数。

3. 当函数之间进行调用时，往往会被处理为多个栈帧的创建和释放，但go语言在编译匿名函数时会采用内联编译，即将调用与被调用编译在一起，平铺式的复制到调用处（类似于cpp的内联函数？），实际执行时会减小栈帧，对性能有一定提升

#### 6.6.2、闭包

```go
func getAnonymousFunc() func(){
    i:=0
    f:=func(){
    //局部变量自增
    i++
    //打印局部变量
    fmt.Println(i)
    }
    return f
}
```

1. 改代码定义了一个函数即getAnonymousFunc（闭包函数），该函数用于生成一个函数对象，可以从返回值func()看出。

2. 该闭包函数定义了一个局部变量i，且i定义与匿名函数之外

3. 匿名函数修改了i的值，一般说来，当外部的闭包函数执行结束，内部的局部变量会被释放，也就是i会被销毁，但是连着两次调用闭包函数，**i不仅存在，还进行了递增**，这是为什么呢？因为局部变量会随着所处函数栈帧的销毁而销毁。

4. **闭包的意义**：该闭包函数中的局部变量i会被分配在**堆空间**，即使外部闭包函数执行完毕，对应的栈内存销毁，i也不会销毁，且由于匿名函数一直保持对i的引用，变量i也不会被GC回收。无论是从getAnonymousFunc()的定义形式，还是其最终内存分配策略，或者代码的执行效果，都可以看出，getAnonymousFunc()生成的匿名函数就像一个封闭的、独立的小王国，具有一直驻留在内存的“环境变量”（我们姑且将闭包看作一个独立的运行环境），同时具有自己的执行逻辑。如同“闭包”这个字眼所表达的那样。

### 6.7函数的强制类型转换

6.7.1从数据类型的定义到函数类型的定义：在不考虑具体实现的情况下，函数要素可以抽象为**参数+返回值的组合**，这种定义不涉及具体的实现，就如同uint8和uint32不考虑具体数值，只限定数据长度一样

6.7.2从数据类型的强制转换到函数类型的强制转换：同数值的强制类型转换，不对变量进行类型声明，由编译器进行类型推导，赋值阶段会出现隐式的类型强制转换

6.7.3函数类型强制转换的意义：在go中**数据类型可以作为参数、返回值、函数的接收者（receiver，从而为数据类型绑定方法）等，这意味着，我们不仅可以像传递普通变量一样传递函数对象，还可以为函数绑定方法，而绑定后的方法可以被函数对象调用，相当于凭空为函数扩展了功能，如以下代码所示。**。通过强制转化，可以让多个与F1结构相同的函数拥有F1所绑定的方法，即此时F1成为了提供公共能力的载体。

6.7.4利用强制转换为函数绑定方法：即创建一个与多个待绑定函数【Target_Functions】类型相同的函数类型Inter_Funcion，为该类型绑定一个test函数，此时将每一个Target_Functions都强制转换为Inter_Function，此时每个新对象都拥有了test方法。

### 6.8、闭包的使用

传统的理解是：封装了变量和函数的独立环境




